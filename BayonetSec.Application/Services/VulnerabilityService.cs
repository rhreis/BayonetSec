using BayonetSec.Application.DTOs;
using BayonetSec.Application.Interfaces;
using BayonetSec.Domain.Entities;
using BayonetSec.Domain.Exceptions;

namespace BayonetSec.Application.Services;

public class VulnerabilityService : IVulnerabilityService
{
    private readonly IVulnerabilityRepository _vulnerabilityRepository;

    public VulnerabilityService(IVulnerabilityRepository vulnerabilityRepository)
    {
        _vulnerabilityRepository = vulnerabilityRepository;
    }

    public async Task<VulnerabilityDto?> GetByIdAsync(Guid id, Guid tenantId)
    {
        var vulnerability = await _vulnerabilityRepository.GetByIdAndTenantAsync(id, tenantId);
        return vulnerability == null ? null : MapToDto(vulnerability);
    }

    public async Task<IEnumerable<VulnerabilityDto>> GetByProjectIdAsync(Guid projectId, Guid tenantId)
    {
        var vulnerabilities = await _vulnerabilityRepository.GetByProjectIdAsync(projectId);
        // Note: In a real implementation, filter by tenant through repository
        return vulnerabilities.Select(MapToDto);
    }

    public async Task CreateAsync(CreateVulnerabilityDto dto, Guid tenantId)
    {
        var vulnerability = new Vulnerability(dto.TestCaseId, dto.Title, dto.Description, dto.Severity);
        await _vulnerabilityRepository.AddAsync(vulnerability);
    }

    public async Task UpdateAsync(Guid id, UpdateVulnerabilityDto dto, Guid tenantId)
    {
        var vulnerability = await _vulnerabilityRepository.GetByIdAndTenantAsync(id, tenantId);
        if (vulnerability == null)
            throw new DomainException("Vulnerability not found");

        vulnerability.Update(dto.Title, dto.Description, dto.Severity, dto.Status, dto.Cve, dto.Remediation, dto.AssignedUserId);
        await _vulnerabilityRepository.UpdateAsync(vulnerability);
    }

    public async Task DeleteAsync(Guid id, Guid tenantId)
    {
        var vulnerability = await _vulnerabilityRepository.GetByIdAndTenantAsync(id, tenantId);
        if (vulnerability == null)
            throw new DomainException("Vulnerability not found");

        await _vulnerabilityRepository.DeleteAsync(vulnerability);
    }

    private static VulnerabilityDto MapToDto(Vulnerability vulnerability)
    {
        return new VulnerabilityDto
        {
            Id = vulnerability.Id,
            TestCaseId = vulnerability.TestCaseId,
            Title = vulnerability.Title,
            Description = vulnerability.Description,
            Severity = vulnerability.Severity,
            Status = vulnerability.Status,
            Cve = vulnerability.Cve,
            Remediation = vulnerability.Remediation,
            AssignedUserId = vulnerability.AssignedUserId,
            CreatedAt = vulnerability.CreatedAt,
            ResolvedAt = vulnerability.ResolvedAt
        };
    }
}